import moment from 'moment';
import _ from 'lodash';

export const STORE_SPACES = `spaces/STORE_SPACES`;
export const STORE_TEAMS = `spaces/STORE_TEAMS`;
export const UPDATE_SPACES_STATUS = `spaces/UPDATE_SPACES_STATUS`;
export const UPDATE_SPACE_WITH_ACTIVITY = `spaces/UPDATE_SPACE_WITH_ACTIVITY`;
export const UPDATE_SPACE_READ = `spaces/UPDATE_SPACE_READ`;
export const REMOVE_SPACE = `spaces/REMOVE_SPACE`;
export const ADD_SPACE = `spaces/ADD_SPACE`;

const TAG_ONE_ON_ONE = `ONE_ON_ONE`;
const TAG_LOCKED = `LOCKED`;


/**
 * Fetches a list of spaces for the authenticated sparkInstance
 *
 * @export
 * @param {Object} sparkInstance
 * @returns {Function} thunk
 */

export function initialFetchSpaces(sparkInstance) {
  return (dispatch) => {
    dispatch(updateSpacesStatus({isFetching: true}));
    return dispatch(fetchSpaces(sparkInstance, {
      sinceDate: moment().subtract(`weeks`, 1).valueOf(),
      conversationsLimit: 10
    }))
    .then(({spaces}) => {
      const maxDate = _.first(_.sortBy(spaces, `lastReadableActivityDate`)).lastReadableActivityDate;
      return dispatch(fetchSpaces(sparkInstance, {
        maxDate,
        conversationsLimit: 50
      }));
    })
    .then(({teams}) => dispatch(fetchSpaces(sparkInstance, {
      conversationsLimit: 1000
    }, teams)))
    .then(({spaces}) => {
      dispatch(updateSpacesStatus({isFetching: false}));
      return spaces;
    });
  };
}

/**
 * Fetches single space from server
 *
 * @export
 * @param {Object} sparkInstance
 * @param {String} spaceId
 * @param {Object} teams
 * @returns {function} thunk
 */
export function fetchSpace(sparkInstance, spaceId, teams = {}) {
  return (dispatch) => sparkInstance.internal.conversation.get({
    id: spaceId
  }, {
    latestActivity: true,
    activitiesLimit: 1,
    participantAckFilter: `all`,
    includeParticipants: true
  }).then((space) => {
    const allTeams = Object.assign({}, teams, generateTeams([space]));
    const constructedSpace = constructSpace(space, allTeams);
    dispatch(storeTeams(allTeams));
    dispatch(addSpace(constructedSpace));
    return constructedSpace;
  });
}


export function removeSpace(id) {
  return {
    type: REMOVE_SPACE,
    payload: {
      id
    }
  };
}


/**
 * Updates the target space with incoming Mercury activity
 *
 * @export
 * @param {Object} activity
 * @param {Boolean} isSelf if actor is the same as this user
 * @param {Boolean} isReadable if the activity is a readable activity
 * @returns {Object} action
 */
export function updateSpaceWithActivity(activity, isSelf, isReadable = false) {
  // We update lastReadableActivityDate, and the activity attached to this Space
  const space = {
    id: activity.target.id,
    latestActivity: activity,
    isLocked: activity.object.tags && activity.object.tags.includes(TAG_LOCKED)
  };

  if (isSelf) {
    space.lastSeenActivityDate = activity.published;
  }

  if (isReadable) {
    space.lastReadableActivityDate = activity.published;
  }

  return {
    type: UPDATE_SPACE_WITH_ACTIVITY,
    payload: {
      space
    }
  };
}

/**
 * Updates the last seen date of a space
 * @param {String} spaceId
 * @param {String} lastSeenDate
 * @returns {Object}
 */
export function updateSpaceRead(spaceId, lastSeenDate) {
  return {
    type: UPDATE_SPACE_READ,
    payload: {
      lastSeenDate,
      spaceId
    }
  };
}


function updateSpacesStatus(status) {
  return {
    type: UPDATE_SPACES_STATUS,
    payload: {
      status
    }
  };
}


function addSpace(space) {
  return {
    type: ADD_SPACE,
    payload: {
      space
    }
  };
}


function storeSpaces(spaces) {
  return {
    type: STORE_SPACES,
    payload: {
      spaces
    }
  };
}


function storeTeams(teams) {
  return {
    type: STORE_TEAMS,
    payload: {
      teams
    }
  };
}

/**
 * Fetches a list of spaces with options
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options
 * @param {Object} teams
 * @returns {Function} thunk
 */

function fetchSpaces(sparkInstance, options = {}, teams = {}) {
  const listOptions = {
    ackFilter: `noack`,
    uuidEntryFormat: true,
    personRefresh: true,
    latestActivity: ``,
    lastViewableActivityOnly: true,
    participantAckFilter: `all`,
    // Only need 2 for One on One conversations
    participantsLimit: 2
  };

  return (dispatch) => sparkInstance.internal.conversation
    .list(Object.assign({}, listOptions, options))
    .then((items) => {
      const allTeams = Object.assign({}, teams, generateTeams(items));
      const spaces = items.map((space) => constructSpace(space, allTeams));
      dispatch(storeTeams(allTeams));
      dispatch(storeSpaces(spaces));
      return {spaces, teams};
    });
}

/**
 * Creates team object to be stored
 *
 * @param {Object} space
 * @param {Object} teams
 * @returns {Object} formatted space object
 */
function constructSpace(space, teams) {
  const s = {
    latestActivity: space.activities.items[0],
    avatar: space.avatar,
    displayName: space.displayName,
    id: space.id,
    url: space.url,
    lastReadableActivityDate: space.lastReadableActivityDate,
    lastSeenActivityDate: space.lastSeenActivityDate,
    conversationWebUrl: space.conversationWebUrl,
    participants: space.participants.items,
    type: space.tags.includes(TAG_ONE_ON_ONE) ? `direct` : `group`,
    published: space.published,
    tags: space.tags
  };

  // Not storing team information if it hasn't been retrieved yet
  if (space.team && teams && teams[space.team.id]) {
    if (teams && teams[space.id]) {
      s.displayName = `General`;
    }
    const {teamColor, generalConversationUuid, id, archived} = space.team;
    s.team = {
      displayName: teams[generalConversationUuid],
      color: teamColor,
      generalConversationUuid,
      id,
      archived
    };
  }

  return s;
}


/**
 * Generate object of ids and team names from collection of spaces
 *
 * @param {Object} spaces
 * @returns {Object} teams
 */
function generateTeams(spaces) {
  const teams = {};
  spaces.forEach((s) => {
    if (s.team && s.team.generalConversationUuid === s.id) {
      teams[s.id] = s.displayName;
    }
  });
  return teams;
}
